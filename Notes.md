## Description

Some short notes for my own benefit, jotting them down as I go. Not organized and likely never reading again lol.

## Notes

- Best practice is brace initialization, eg: int a { 0 }; // if using value OR: int a {}; // if not using value
- Dont make unused vars (obviously), but can use [[maybe_unused]] before a variable to remove unused warning
- Should always use explicit namespace id when available, eg use std::cout instead of just cout. Avoid 'using namespace `${namespace}`'
- Macro is a rule that defines how input text is converted into replacement output text
- Preprocessor replaces identifier with substitution text (#define identifier substitution_text) -> not that useful
- You can exclude the substitution text and preprocessor will replace identifier with nothing (learn more later, apparently useful)
- Use #ifdef identifier with #endif to only compile code inside the block if the identifier has been previously defined
  - eg: #ifdef MY_NAME std::cout << "Derek"; #endif will only compile IF the #define MY_NAME exists
- Can use #ifndef (if not defined) to do the same thing
- Can use #ifdef 0 to skip a block in compiler
- This still works with substitution, text only subs in normal code, it is ignored for other directives
- Directives are compiled from top to bottom of the file, do not affect other files (even after linked), ignores function scope
- Make sure .cpp files include their matching .h file if one exists, catches errors like invalid return types or functions defs
- Use double quotes for custom headers, angle brackets <> for built in, os, or third party
- Dont manually direct to other folders for including .h files, tell compiler or ide where to look for other files
- g++ or vscode use "-I/source/includes", option
- Dont rely on transitive inclusion, each file should manually include any other file it requires to compile
- Best practice: Include paired header, then others from project, third party, then standard library
- Header guard uses ifndef then a define to prevent a headerfile from being compiled twice and avoids duplicate definitions after preprocessing
- To avoid files with duplicate names in different directories using the same guard name follow one of these name schemes for guards
  - PROJECT_PATH_FILE_H
  - RANDOM LARGE NUMBER_H (I don't like this one)
  - FILE_CREATION DATE_H (Also not a fan)
- The files can still be declared once per .cpp file where they're included though, so it's best practice to only define matching file functions (add.cpp + add.h) withing the .cpp, then include the .h and use it wherever needed
- Modern cpp has #pragma, but it shouldn't be used as header guards offer maximum portability
  - eg use: #pragma once
  - This does the same thing as a guard in a much simpler format, but again isn't great for portability
- Can use preprocessor tags to have conditional debugging
- Debuggers & Loggers are best practice (Not news)
- Book recommends I follow best practice and do defensive coding
- Use static analysis tool like sonarqube to find areas that aren't best practice compliant
- Types with \_t are modern types, such as chat8_t and std::nullptr_t
- Strings are not a fundamental type in C++, but you can do arrays of char or use std::string library
- To be space efficient you can be specific with var sizes, but for better compatibility we shouldn't assume that variables are larger than the specified minimum size
- Objects of fundamental data types are usually extremely fast
- Can use sizeof() to determine size in bytes of a type or variable
- Best practice: Prefer var shorthands (eg: use short instead of unsigned short int)
- C++ wont round if dividing ints that turn into fractions, it will simply drop the remainder
- Integers are default signed, can also defined them as unsigned (eg: unsigned int x{3})
  - Unsigned can only be positive, but most devs avoid them
  - Can lead to bad cases of overflow in simple problems like subtraction since below 0 it will overflow
  - Unsigned are okay to use in bit manipulation and are unavoidable in some cases such as array indexing
- Dealing with minimum width integers is annoying since some architectures may allow more bytes, to resolve this C99 introduced fixed width integers
  - C++11 adopted these
- Use <cstdint> to access
- std::int8_t, uint8_t... all the way to 64 bit/8 byte.
  - uint8_t are often treated like unsigned char, int8_t often treated like signed char
  - Issues: Not always supported on architecture. Can be slower than a wider type on some architectures
  - Eg: Your cpu may be better at processing a 64 bit int rather than a 32 bit int
- C++ defines alternative ints that are guarenteed to be defined
  - fast ints provide the fastest ints of a minimum width
  - least ints provide the smallest ints of a minimum width
- Integer best practice
  - prefer int if size doesnt matter
  - prefer std::int#\_t when storing a quantity of guaranteed range
  - prefer std::uint#\_t for bit manipulation or when wrap behaviour is well defined
  - avoid unsigned types for holding quantities
  - avoid 8-bit fixed types
  - avoid fast & least
  - avoid compiler specific ints
- Float best practice
  - Always make sure default value/first assignment matches the type
  - double y{5.0} defaults to double, for float use y{5.0f}
  - Doing just y{5} is an integer
- Default C++ does 6 digit percision, can use std::cout << std::setpercision(n) to set it to higher number
  - Part of <iomanip> library
- If percision is too low for a number we can get rounding error
- Best practice: Favor double over float unless space is super important, leads to less floating point errors
- Inf for infinity, NaN for not a number
- Conditionals use if, else if, and else
- char is stored as an integer and interpreted as an ascii character
- Best practice is single quotes for chars
- Best practice is to define with char, not int
  - eg: both char ch{'a'} and char ch{97} work and produce the same thing, but the former is best practice
  - Avoids mixing up ch{5} and ch{'5'} which would produce very different results
- Using cin allows you to enter more than one character, but char only accepts one. This leads to it taking whatever is next in queue if available
- String literals use double quotes, chars use single quotes
  - Put standalone chars in single quotes as best practice, including escape sequeneces like '\n'
  - Avoid multichar literals like '56'
- Types like w_char should be avoided unless interfacing with windows api that specifies it.
- C++ typically uses <> brackets for types
- static_cast<type>(data) to cast data to a type
- Constants must be init when defined
- Uses const type id {value}; syntax
- Don't use const for pass or return by value best practice
- Prefer const over macros with substiution text
- Runtime const uses function, compile time uses expression
- Any var whos value is known at compile time and doesnt change should be a compile time const
- compile time const use 'constexpr', runtime uses 'const'
- For literals perfer suffix L (uppercase) over lowercase
- 0 before number means its octal, 0x before means its hexidecimal
- 0b follow by binary number assigned 16 bit binary
- 0b11 is 3 in binary -> 0000 0000 0000 0011 (C++14 and up)
- Can also do 0b0004 (0100), 0b00FF (1111 1111), etc where each column value is the hex cast to binary 0bFFFF being max value
- To make long literals easier to read C++14 allows ' as a separater
  - eg: 2'132'456'462 is easier to read than 2123456462
  - Works for binary 0b0001'1101;
- Can do binary output with #include <bitset>
  - std::bitset<8> bin1{0b1100'0101}; (means 8 bits)
  - Works for hex, binary
- #include <string> to start working with strings
  - std::string name {}; where std::string is the type
  - Note strings should be in double quotes ""
  - eg: std::string name { "Derek" };
- string cant use cin since it breaks whitespace and accepts only chars
- string uses its own method std::getline
  - eg: std::getline(std::cin >> std:ws, name);
  - std::ws tells code to ignore any leading whitespace before extraction
- best practice: If using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace.
- String length is easy, just use string.length: eg: name.length
  - C++20 also allows std::ssize(name) to get the length as a signed int
- Best practice: Don't pass std::string by value, use std::string_view or pass by reference
- use std::literals to access string literals. s is string, sv is string_view
- Very minimal support of constexpr std::string was just added in C++20, prefer to use string_view if a constant expression is needed for a string
- string_view added in C++17
  - Prefer string_view for any readonly strings, especially function params, as it is faster and less likely to crash
  - Has full support of constexpr
  - Can use std::string_view sv{ s }; and compiler will autoconvert string 's' to a string_view
  - Same works other way around, can use sv to make a string. Can also use static_case<std::string>(sv)'
- Dont overuse paranthesis, especially with single assignment expressions
- a lot of math in cmath library #include <cmath>
- Best practice: Use comma is a separator, avoid using its operator functionality
- C++ has ? functionality, a ? b : c;
  - Only use in simple situations, nested ? functions become hard to read
  - Best practice, always paranthesis the conditional portion of the conditional operator
  - Conditionals evaluate as expressions, so they can be used for constexpr
    - Sometimes this is the only choice when using constexpr, if else wont work here
- use namespace keyword to define your own
- DO NOT add custom functionality to std namespace
- Can nest namespaces by regular code convention or namespace foo::goo
- Can use alias like: namespace id = foo:goo;
- Recommended to use namespaces to separate application specific code from more reusable code
- Variable with internal linkage is locked to a single file, external means it can be used in other files
- You can use the 'static' keyword to make a non-constant global internal
- Constants are internal by default and ignore 'static' keyword
- Internal things like constants can be made external using 'extern'
  - If you do not set a default value to a non-constants extern it is interpreted as a forward declaration of the variable (don't do it)
- DO NOT use non-constant globals
  - Always try to use local variables when possible
- The best prefix for a global variable is '//'
  - haha lol haha
- Can use external .h with namespace in the .cpp to store global constants
- C++17 adds inline constants
  - Inline variables allow multiple defintions
  - Linker compiles into 1 definitions
    - Eg: if you had 10 files using a non-inline variable you end with 10 definitions, if you use inline we get only 1 definition (as if it only exists in one .cpp file)
  - All definitions of inline variables must be identical
  - If a file uses an inline variable its defintion must be present within the file
  - BEST PRACTICE is to use inline constexpr variables in a header file for all global constants (string_view for strings)
- The static keyword means something different locally
  - On local files it turns automatic duration to static duration (var now created at start of program, destroyed at end)
  - Allows functions to remember the value of their variables
  - Best practice: If using static local variables always declare a default value. The default value will be initialized ONE TIME once the program starts (not when the function is run)
  - Can use static local constants, variable init is expensive so this can be speed efficient depending on how often the function is run
  - Avoid static local IF the variable needs to be reset
- AVOID USING DIRECTIVES (eg: using namespace std)
  - We prefer explicit naming, this is counterintuitive to that
  - using declarations are fine when used inside blocks/locally (eg: using std::cout; tells the code what 'cout' is and allows you to do: cout << "stuff";)
- Inline functions
  - Better performance at the cost of some readability
  - Functions all either: must be expanded, can be expanded, or cannot be expanded
  - If we use the keyword 'inline' on a function it tells the compiler to do inline expansion
    - reduced function call overhead, faster
  - Avoid inline functions, contradicts with a functions ability to have multiple defintions (same rules as inline constants)
  - Some functions will be implicitly treated as inline (class, struct, union type defs, constexpr, consteval)
- Can mark functions with constexpr return type
  - Should use if function needs to return compile time constants/is being assigned to a constexpr
  - These functions are implicity inline as previously mentioned
  - Can also be evaluated at runtime if using a non-compile time variable as a parameter
  - A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.
    - Think of it as 'can be used in constexpr' not 'will be evaluated at compile-time'
  - C++20 adds ability to check if a constant is evaluated at compile time
    - #include <type_traits> -> std::is_constant_evaluated(); returns true if compile-time evaluation occurs
  - C++20 adds better way around this as well, consteval functions
    - consteval MUST be evaluated at compile time, will error if a parameter is only available at runtime
    - Should use if something must be evaluated at compile time for performance reasons
- Unname namespace treated as part of the parent namespace
- Inline namespaces can be used to version content
  - Anything inside inline namespace considered part of the parent namespace, but not everything inside has internal linkage
- Use switch over if-else chains when possible
- Default case goes last
- Use break; or return; to avoid switch statement fallthrough
  - Can use [[fallthrough]]; to indicate intentional fallthrough
- When defining variables inside a switch statement opt to use a block (best practice)
- Can use goto statements similar to Assembly
  - eg: tryAgain: 'logic'; if (something) { goto tryAgain; } return 0;
- Avoid goto over regular loops
- Use while(true) for intended infinite loops
  - If counted loop opt for signed int
  - Favor while loops over do while loops
- Defining multiple variables (in the init-statement) and using the comma operator (in the end-expression) is acceptable inside a for statement.
  - eg: for(int x{ 0 }, y{ 9 }; x < 10; ++x, --y) { 'code' } is acceptable
  - Prefer for loops over whiles when there is an obvious loop variable, otherwise prefer while
- Can use break; to exit early, or continue; to go to top of loop early
  - Should do so only when the simplify the loop logic (faster and more readable)
  - Can use early returns if they simplify the entire functions logic
- halt exists the program early, liek std::abort;
  - Should only be used if there is no safe way to return normally to the main function
  - Should prefer using exceptions (try catch) in all cases to safely handle these errors
- Write code in small 'units' and write UTs as you go
  - Can write UTs beforehand and write functions to fit tests, known as test driven development
  - Always aim for 100% code coverage
- Use assert to document cases that should be logically impossible
- When defining a reference with & put the & next to the type, not the variable (best practice, both work)
- Favor lvalue references to const over lvalue references to non-const unless you need to modify the object being referenced.
- Best practice: pass fundamental types by value, pass other types or structs by reference
- Prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy. If you’re not sure whether an object is cheap or expensive to copy, favor pass by const reference.
- For pointers place the \* next to the type
  - Always init the pointers
- ptr = &y changes what we're pointing to, \*ptr = y changes the value of what is being pointed to
- Value initialize your pointers (to be null pointers) if you are not initializing them with the address of a valid object.
- Can use nullptr literal pointer with nullptr keyword
  - Use nullptr when you need a null pointer literal for initialization, assignment, or passing a null pointer to a function.
  - A pointer should either hold the address of a valid object, or be set to nullptr. That way we only need to test pointers for null, and can assume any non-null pointer is valid.
- Favor references over pointers unless the additional capabilities provided by pointers are needed.
- Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.
  - Avoid returning references to non-const local static variables.
  - Prefer return by reference over return by address unless the ability to return “no object” (using nullptr) is important.
- A Smart pointer is a composition class that is designed to manage dynamically allocated memory and ensure that memory gets deleted when the smart pointer object goes out of scope.
