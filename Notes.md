## Description

Some short notes for my own benefit, jotting them down as I go. Not organized and likely never reading again lol.

## Notes

- Best practice is brace initialization, eg: int a { 0 }; // if using value OR: int a {}; // if not using value
- Dont make unused vars (obviously), but can use [[maybe_unused]] before a variable to remove unused warning
- Should always use explicit namespace id when available, eg use std::cout instead of just cout. Avoid 'using namespace `${namespace}`'
- Macro is a rule that defines how input text is converted into replacement output text
- Preprocessor replaces identifier with substitution text (#define identifier substitution_text) -> not that useful
- You can exclude the substitution text and preprocessor will replace identifier with nothing (learn more later, apparently useful)
- Use #ifdef identifier with #endif to only compile code inside the block if the identifier has been previously defined
  - eg: #ifdef MY_NAME std::cout << "Derek"; #endif will only compile IF the #define MY_NAME exists
- Can use #ifndef (if not defined) to do the same thing
- Can use #ifdef 0 to skip a block in compiler
- This still works with substitution, text only subs in normal code, it is ignored for other directives
- Directives are compiled from top to bottom of the file, do not affect other files (even after linked), ignores function scope
- Make sure .cpp files include their matching .h file if one exists, catches errors like invalid return types or functions defs
- Use double quotes for custom headers, angle brackets <> for built in, os, or third party
- Dont manually direct to other folders for including .h files, tell compiler or ide where to look for other files
- g++ or vscode use "-I/source/includes", option
- Dont rely on transitive inclusion, each file should manually include any other file it requires to compile
- Best practice: Include paired header, then others from project, third party, then standard library
- Header guard uses ifndef then a define to prevent a headerfile from being compiled twice and avoids duplicate definitions after preprocessing
- To avoid files with duplicate names in different directories using the same guard name follow one of these name schemes for guards
  - PROJECT_PATH_FILE_H
  - RANDOM LARGE NUMBER_H (I don't like this one)
  - FILE_CREATION DATE_H (Also not a fan)
- The files can still be declared once per .cpp file where they're included though, so it's best practice to only define matching file functions (add.cpp + add.h) withing the .cpp, then include the .h and use it wherever needed
- Modern cpp has #pragma, but it shouldn't be used as header guards offer maximum portability
  - eg use: #pragma once
  - This does the same thing as a guard in a much simpler format, but again isn't great for portability
- Can use preprocessor tags to have conditional debugging
- Debuggers & Loggers are best practice (Not news)
- Book recommends I follow best practice and do defensive coding
- Use static analysis tool like sonarqube to find areas that aren't best practice compliant
- Types with \_t are modern types, such as chat8_t and std::nullptr_t
- Strings are not a fundamental type in C++, but you can do arrays of char or use std::string library
- To be space efficient you can be specific with var sizes, but for better compatibility we shouldn't assume that variables are larger than the specified minimum size
- Objects of fundamental data types are usually extremely fast
- Can use sizeof() to determine size in bytes of a type or variable
- Best practice: Prefer var shorthands (eg: use short instead of unsigned short int)
- C++ wont round if dividing ints that turn into fractions, it will simply drop the remainder
- Integers are default signed, can also defined them as unsigned (eg: unsigned int x{3})
  - Unsigned can only be positive, but most devs avoid them
  - Can lead to bad cases of overflow in simple problems like subtraction since below 0 it will overflow
  - Unsigned are okay to use in bit manipulation and are unavoidable in some cases such as array indexing
- Dealing with minimum width integers is annoying since some architectures may allow more bytes, to resolve this C99 introduced fixed width integers
  - C++11 adopted these
- Use <cstdint> to access
- std::int8_t, uint8_t... all the way to 64 bit/8 byte.
  - uint8_t are often treated like unsigned char, int8_t often treated like signed char
  - Issues: Not always supported on architecture. Can be slower than a wider type on some architectures
  - Eg: Your cpu may be better at processing a 64 bit int rather than a 32 bit int
- C++ defines alternative ints that are guarenteed to be defined
  - fast ints provide the fastest ints of a minimum width
  - least ints provide the smallest ints of a minimum width
- Integer best practice
  - prefer int if size doesnt matter
  - prefer std::int#\_t when storing a quantity of guaranteed range
  - prefer std::uint#\_t for bit manipulation or when wrap behaviour is well defined
  - avoid unsigned types for holding quantities
  - avoid 8-bit fixed types
  - avoid fast & least
  - avoid compiler specific ints
- Float best practice
  - Always make sure default value/first assignment matches the type
  - double y{5.0} defaults to double, for float use y{5.0f}
  - Doing just y{5} is an integer
- Default C++ does 6 digit percision, can use std::cout << std::setpercision(n) to set it to higher number
  - Part of <iomanip> library
- If percision is too low for a number we can get rounding error
- Best practice: Favor double over float unless space is super important, leads to less floating point errors
- Inf for infinity, NaN for not a number
- Conditionals use if, else if, and else
- char is stored as an integer and interpreted as an ascii character
- Best practice is single quotes for chars
- Best practice is to define with char, not int
  - eg: both char ch{'a'} and char ch{97} work and produce the same thing, but the former is best practice
  - Avoids mixing up ch{5} and ch{'5'} which would produce very different results
- Using cin allows you to enter more than one character, but char only accepts one. This leads to it taking whatever is next in queue if available
- String literals use double quotes, chars use single quotes
  - Put standalone chars in single quotes as best practice, including escape sequeneces like '\n'
  - Avoid multichar literals like '56'
- Types like w_char should be avoided unless interfacing with windows api that specifies it.
- C++ typically uses <> brackets for types
- static_cast<type>(data) to cast data to a type
- Constants must be init when defined
- Uses const type id {value}; syntax
- Don't use const for pass or return by value best practice
- Prefer const over macros with substiution text
- Runtime const uses function, compile time uses expression
- Any var whos value is known at compile time and doesnt change should be a compile time const
- compile time const use 'constexpr', runtime uses 'const'
- For literals perfer suffix L (uppercase) over lowercase
- 0 before number means its octal, 0x before means its hexidecimal
- 0b follow by binary number assigned 16 bit binary
- 0b11 is 3 in binary -> 0000 0000 0000 0011 (C++14 and up)
- Can also do 0b0004 (0100), 0b00FF (1111 1111), etc where each column value is the hex cast to binary 0bFFFF being max value
- To make long literals easier to read C++14 allows ' as a separater
  - eg: 2'132'456'462 is easier to read than 2123456462
  - Works for binary 0b0001'1101;
- Can do binary output with #include <bitset>
  - std::bitset<8> bin1{0b1100'0101}; (means 8 bits)
  - Works for hex, binary
- #include <string> to start working with strings
  - std::string name {}; where std::string is the type
  - Note strings should be in double quotes ""
  - eg: std::string name { "Derek" };
- string cant use cin since it breaks whitespace and accepts only chars
- string uses its own method std::getline
  - eg: std::getline(std::cin >> std:ws, name);
  - std::ws tells code to ignore any leading whitespace before extraction
- best practice: If using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace.
- String length is easy, just use string.length: eg: name.length
  - C++20 also allows std::ssize(name) to get the length as a signed int
- Best practice: Don't pass std::string by value, use std::string_view or pass by reference
- use std::literals to access string literals. s is string, sv is string_view
- Very minimal support of constexpr std::string was just added in C++20, prefer to use string_view if a constant expression is needed for a string
- string_view added in C++17
  - Prefer string_view for any readonly strings, especially function params, as it is faster and less likely to crash
  - Has full support of constexpr
  - Can use std::string_view sv{ s }; and compiler will autoconvert string 's' to a string_view
  - Same works other way around, can use sv to make a string. Can also use static_case<std::string>(sv)'
- Dont overuse paranthesis, especially with single assignment expressions
- a lot of math in cmath library #include <cmath>
- Best practice: Use comma is a separator, avoid using its operator functionality
- C++ has ? functionality, a ? b : c;
  - Only use in simple situations, nested ? functions become hard to read
  - Best practice, always paranthesis the conditional portion of the conditional operator
  - Conditionals evaluate as expressions, so they can be used for constexpr
    - Sometimes this is the only choice when using constexpr, if else wont work here
